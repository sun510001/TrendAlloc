# Stock Trading Backtest System

A Python-based multi-asset backtesting system that includes data downloading, yield-to-price conversion engines, a backtest engine with pluggable rebalance algorithms, and a FastAPI-based HTTP API plus a lightweight web console.

The current focus is on equal-weight rebalancing backtests for long-term asset portfolios (such as a Permanent Portfolio), with support for arbitrary asset configurations and multiple algorithms.

---

## Project Structure

```text
project_root/
├── backend/
│   ├── api.py           # FastAPI HTTP API + simple Web UI (/ui)
│   └── service.py       # Backtest service layer: BacktestConfig/Result + run_backtest_job + algorithm mapping
│
├── data/                # Raw downloaded data (one CSV per asset, using sanitized asset names)
├── data_processed/
│   ├── aligned_assets.csv              # Aligned price matrix (backtest input)
│   └── backtest_results_*.html         # Plotly performance charts generated by each backtest run
│
├── data_loader/
│   ├── yahoo_downloader.py  # Incremental OHLCV downloader using yfinance
│   └── data_processor.py    # Convert yield series to prices and align all assets
│
├── strategies/
│   ├── backtest_engine.py   # Core backtest engine (time loop + pluggable rebalance_fn)
│   └── algorithms.py        # Rebalance algorithms collection (permanent_portfolio_rebalance, etc.)
│
├── utils/
│   ├── decorators.py        # Common decorators (e.g., retry)
│   └── tools.py             # Timezone and time-offset utility functions
│
├── logs/app.log             # Application log file
├── logger.py                # Central logging configuration
├── main_download.py         # CLI: download data and generate aligned_assets.csv
├── main_backtest.py         # CLI: run a local backtest (optionally with custom rebalance_fn)
├── backend/api.py           # FastAPI app entrypoint
├── backend/service.py       # Core backtest service logic
├── requirements.txt
└── README.md
```

---

## Module Overview

### 1. `backend/`: HTTP API and Service Layer

#### `backend/service.py`

- **BacktestConfig**: Backtest configuration model (Pydantic BaseModel). Fields:
  - `data_file`: Path to the aligned data file (default `data_processed/aligned_assets.csv`).
  - `output_dir`: Directory where backtest HTML charts are written (default `data_processed`).
  - `start_date` / `end_date`: Backtest date range.
  - `initial_capital`: Initial portfolio capital.
  - `fees`: Transaction fee rate (e.g. 0.0005 = 5 bps).
  - `rebalance_freq`: Rebalance frequency (e.g. `"QE"` for quarter end, `"YE"` for year end).
  - `benchmark_cols`: List of column names (from `aligned_assets.csv`) to show as benchmarks in the chart.
  - `algorithm`: Algorithm key selected by the front-end; mapped to a concrete rebalance function.

- **BacktestResult**: Backtest result model:
  - `stats`: Backtest statistics (Total Return, CAGR, Sharpe Ratio, Max Drawdown, Volatility, Years, etc.).
  - `result_html_path`: Relative path (from project root) to the generated HTML chart.
  - `result_url`: URL under `/results` for direct access to the chart.
  - `algorithm`: Echo of the algorithm key used for this run.

- **ALGORITHM_MAP**: Algorithm registry mapping `algorithm` keys to Python functions:
  - Currently includes: `"permanent_portfolio"` → `permanent_portfolio_rebalance`.
  - To add new algorithms, implement them in `strategies/algorithms.py` and register them here.

- **run_backtest_job(cfg: BacktestConfig) -> BacktestResult**:
  - Resolves `cfg.data_file` / `cfg.output_dir` to absolute paths.
  - Uses `cfg.algorithm` to retrieve the appropriate `rebalance_fn` from `ALGORITHM_MAP`.
  - Instantiates `PermanentPortfolioStrategy` and calls `run_backtest(...)` with the selected rebalance function.
  - Computes backtest statistics via `get_performance_stats()` and generates an HTML chart via `plot_results(...)`.
  - Returns a `BacktestResult` object containing stats, HTML paths, and the algorithm key used.

#### `backend/api.py`

- FastAPI app exposing HTTP APIs and a simple web UI:
  - `GET /`:
    - Renders a simple welcome page with links to `/ui` (backtest console) and `/docs` (OpenAPI docs).
  - `GET /ui`:
    - Returns an interactive HTML console that allows users to:
      - Select a backtest algorithm (loaded dynamically from `/api/algorithms`).
      - Adjust backtest parameters (date range, initial capital, benchmarks).
      - Trigger a backtest via `POST /api/backtest`.
      - View statistics and the generated Plotly chart iframe on the same page.
  - `GET /api/algorithms`:
    - Returns the list of available algorithms in the form:
      - `[{"key": ..., "label": ..., "description": ...}, ...]`.
  - `POST /api/backtest`:
    - Accepts a `BacktestConfig` JSON payload.
    - Delegates to `run_backtest_job` and returns `BacktestResult` as JSON.
  - Static mount `/results`:
    - Serves `data_processed` as static files so `result_url` can be directly opened in the browser.

> The `/ui` console is convenient for manual testing and quick interaction. For production UIs, you can call `/api/algorithms` and `/api/backtest` directly from your front-end.

---

### 2. `data_loader/`: Data Download and Processing

#### `data_loader/yahoo_downloader.py`

- **sanitize_filename(name: str) -> str**:
  - Produces a filesystem-safe name from an asset name:
    - Strips characters other than letters, digits, underscores, spaces and hyphens.
    - Collapses spaces/hyphens into a single underscore.
    - Converts to lowercase.
  - Ensures consistent naming between download and processing.

- **YahooIncrementalLoader**:
  - `__init__(storage_path: str = "./data")`:
    - Sets the raw data directory and ensures it exists.
  - `_get_existing_data(file_path: str) -> pd.DataFrame`:
    - Reads an existing CSV (if present), returning an empty DataFrame on missing file or parse error.
  - `download_symbol(ticker: str, name: str, start_date_fallback: str = "1985-01-01")`:
    - Computes `safe_name = sanitize_filename(name)` and uses `<storage_path>/<safe_name>.csv` as the file path.
    - If the file exists, continues downloading from the next date after the last row.
    - Uses `yfinance.download(..., auto_adjust=True)` to fetch adjusted OHLCV.
    - Handles MultiIndex columns and normalizes them into `['Open', 'High', 'Low', 'Close', 'Volume']`.
    - Fills missing OHLC values (e.g., replacing zeros with `Close`) and fills missing volume with 0.
    - Merges newly downloaded data with existing data, de-duplicates by index, and sorts by date.
  - `download_batch(assets: List[Dict[str, Any]], start_year: int = 1985)`:
    - Iterates over an `assets` configuration list and calls `download_symbol` for each asset.

#### `data_loader/data_processor.py`

- **DataProcessor**:
  - `__init__(raw_path: str = "./data", processed_path: str = "./data_processed")`:
    - Sets raw and processed data directories and ensures the processed path exists.
  - `_load_raw(safe_name: str) -> pd.Series`:
    - Loads the CSV for `safe_name` from `raw_path`, reading the `Close` column (or the only column if `Close` is missing).
    - Removes duplicate index entries and ensures the series is sorted by date.
  - `bond_pricing_engine(yield_series: pd.Series, duration: float = 20.0, initial_price: float = 100.0) -> pd.Series`:
    - Converts a bond yield series (e.g., 4.5 meaning 4.5%) to a synthetic bond price series using a duration-based approximation:
      - Daily return ≈ yield/100/252 − duration * Δyield.
      - Accumulates returns via `(1 + daily_return).cumprod()` and scales by `initial_price`.
  - `cash_pricing_engine(yield_series: pd.Series, initial_price: float = 100.0) -> pd.Series`:
    - Converts a short-term yield series (e.g., T-bill) into a "cash" price series using simple interest approximation.
  - `process_and_align(assets: List[Dict[str, Any]])`:
    - For each asset in `assets`:
      - Derives `safe_name` from `name` via `sanitize_filename`.
      - Loads the corresponding raw series.
      - If `kind == "price"`: uses the raw price directly.
      - If `kind == "yield"` and `engine == "bond"`: applies `bond_pricing_engine`.
      - If `kind == "yield"` and `engine == "cash"`: applies `cash_pricing_engine`.
    - Combines all resulting price series into a single DataFrame and aligns them via `dropna()`.
    - Saves the aligned price matrix as `aligned_assets.csv` in `processed_path`, with columns equal to each asset's `name`.

> The entire ETL pipeline is driven by `main_download.py`, which first downloads raw data and then processes it into `aligned_assets.csv`.

---

### 3. `strategies/`: Backtest Engine and Algorithms

#### `strategies/algorithms.py`

- **permanent_portfolio_rebalance(current_units: np.ndarray, prices: np.ndarray, fees: float) -> tuple[np.ndarray, float]**:
  - Implements an equal-weight rebalance strategy:
    - Computes current portfolio value as `sum(current_units * prices)`.
    - Sets the target value per asset to `current_val / n_assets`.
    - Computes the differences between target and current asset values to derive trade volume and fees.
    - Deducts fees from the portfolio value, then re-allocates equally across all assets to determine new units.
  - Returns `(new_units, new_portfolio_value)`.


#### `strategies/backtest_engine.py`

- **PermanentPortfolioStrategy**:
  - `__init__(data_path: str, initial_capital: float = 10000.0)`:
    - Loads the aligned price matrix from `data_path` (e.g., `aligned_assets.csv`) and sets the initial capital.
  - `_load_data()`:
    - Reads the CSV using `pandas.read_csv` with `Date` as index and converts all values to floats.
  - `run_backtest(start_date: Optional[str], end_date: Optional[str], rebalance_freq: str, fees: float, rebalance_fn=permanent_portfolio_rebalance) -> None`:
    - Slices the data to the specified date range.
    - Computes rebalance dates via `resample(rebalance_freq).last()`.
    - Initializes equal capital allocation across all assets at the start date.
    - Iterates over each trading day:
      - Marks the portfolio to market.
      - If the day is a rebalance date, calls `rebalance_fn(current_units, today_prices, fees)` to compute new units and value.
    - Stores the resulting time series of portfolio values and computes the drawdown.
  - `get_performance_stats() -> Dict[str, float]`:
    - Calculates daily returns, total return, CAGR, Sharpe ratio, max drawdown, annualized volatility, and the number of years.
  - `plot_results(output_dir: str, benchmark_cols: Union[str, List[str]]) -> str`:
    - Normalizes the strategy portfolio value to start at 0% and does the same for each benchmark column over the same date range.
    - Generates an interactive Plotly chart comparing the strategy and benchmarks.
    - Writes the chart to `output_dir/backtest_results_YYYYMMDD_HHMMSS.html` and returns the file path.

> The engine is asset-agnostic: any aligned price matrix with one column per asset can be used as input.

---

### 4. Entrypoints: `backend/` and `main_*.py`

#### `main_download.py`

- CLI script that orchestrates the data download and preprocessing pipeline.
- Uses a top-level `ASSETS` configuration list specifying:
  - `name`: Logical asset name (also used as column name and front-end key).
  - `ticker`: Yahoo Finance symbol (e.g., `^NDX`).
  - `kind`: Either `"price"` or `"yield"`.
  - `engine`: For yield assets, either `"bond"` or `"cash"`.
- Execution flow:
  1. `YahooIncrementalLoader.download_batch(ASSETS, start_year)` downloads or updates raw asset data under `./data`.
  2. `DataProcessor.process_and_align(ASSETS)` generates `./data_processed/aligned_assets.csv`.

#### `main_backtest.py`

- CLI script that loads `aligned_assets.csv`, runs a single backtest, and prints stats and the chart path.
- Demonstrates how to use a custom rebalance function (e.g., `my_new_rebalance`) with `PermanentPortfolioStrategy.run_backtest`.
- Intended mainly for local testing; for front-end integration, prefer calling the FastAPI `/api/backtest` endpoint instead.

---

### 5. `utils/` and `logger.py`

#### `utils/decorators.py`

- **retry(max_retries: int = 3, delay: int = 2, exceptions: tuple = (Exception,))**:
  - Decorator that retries a function upon specified exceptions for a given number of attempts, with a delay between attempts.

#### `utils/tools.py`

- **get_time_difference(hour: int = 9, minute: int = 30, region: str = "America/New_York") -> int**:
  - Returns the time difference in minutes between the current time in a specified timezone and a given hour:minute on the same day.
- **get_time_offset(datetime_obj: datetime) -> float**:
  - Returns the time difference in seconds between the current local time and a given `datetime_obj`.

#### `logger.py`

- Central logging configuration used by the whole project:
  - Log format: `[YYYY.MM.DD-HH:MM:SS.mmm][threadName][LEVEL] message`.
  - Outputs to both console and `logs/app.log` via a `RotatingFileHandler`.

---

## Installation and Environment

### 1. Create a virtual environment (recommended)

```bash
python -m venv .venv
source .venv/bin/activate  # Windows: .venv\Scripts\activate
```

### 2. Install dependencies

```bash
pip install -r requirements.txt
```

---

## Usage Guide

### 1. Data Download and Preprocessing

1. Configure the `ASSETS` list in `main_download.py`:
   - `name`: Logical asset name (column name and front-end key).
   - `ticker`: Yahoo Finance ticker.
   - `kind`: `"price"` or `"yield"`.
   - `engine`: For yield assets, `"bond"` or `"cash"`.

2. Run the ETL pipeline:

   ```bash
   python main_download.py
   ```

3. Verify:
   - Raw data files exist under `data/` (e.g., `nasdaq100.csv`).
   - `data_processed/aligned_assets.csv` was created and contains aligned price series.

### 2. Local Script Backtest

```bash
python main_backtest.py
```

- Adjust backtest parameters (date range, initial capital, rebalance frequency, benchmarks) at the top of `main_backtest.py`.
- An HTML chart (`backtest_results_*.html`) will be created in `data_processed/`.

### 3. Backtest via FastAPI (Recommended for Front-End Integration)

1. Start the API server:

   ```bash
   python backend/api.py
   # or
   uvicorn backend.api:app --reload
   ```

2. Open in your browser:

   - Web console UI: `http://127.0.0.1:8000/ui`
   - API docs (Swagger UI): `http://127.0.0.1:8000/docs`

3. Using the `/ui` console:

   - Select an algorithm (currently `Permanent Portfolio (Equal Weight)`).
   - Choose a date range and initial capital.
   - Specify benchmark columns (matching the `aligned_assets.csv` columns).
   - Click **Run Backtest** and observe:
     - Statistics cards (Total Return, CAGR, Sharpe Ratio, Max Drawdown, Volatility, Years).
     - An embedded performance chart (iframe using `result_url`).

4. Calling the API directly (for front-end apps):

   - `GET /api/algorithms` — retrieve the list of algorithms for populating a dropdown.
   - `POST /api/backtest` — trigger a backtest with a JSON payload, for example:

     ```json
     {
       "data_file": "data_processed/aligned_assets.csv",
       "output_dir": "data_processed",
       "start_date": "2018-01-01",
       "end_date": "2024-12-31",
       "initial_capital": 100000,
       "fees": 0.0005,
       "rebalance_freq": "QE",
       "benchmark_cols": ["Nasdaq100", "GoldIndex", "US30Y", "US3M"],
       "algorithm": "permanent_portfolio"
     }
     ```

   - Example response:

     ```json
     {
       "stats": { "Total Return": 0.63, "CAGR": 0.07, "Sharpe Ratio": 0.8, ... },
       "result_html_path": "data_processed/backtest_results_20260215_214500.html",
       "result_url": "/results/backtest_results_20260215_214500.html",
       "algorithm": "permanent_portfolio"
     }
     ```

---

## FAQ

- **Q: Why does `/api/backtest` return HTTP 400 or 500?**
  - Common causes:
    - `start_date` / `end_date` are invalid strings (e.g., the default `"string"` in Swagger; use `YYYY-MM-DD` or `null`).
    - The `data_file` path is wrong or `aligned_assets.csv` has not been generated yet.
    - `benchmark_cols` contains names that do not exist in `aligned_assets.csv`.
    - `algorithm` is not defined in `ALGORITHM_MAP`.

- **Q: How can I add a new backtest algorithm?**
  1. Implement a new rebalance function in `strategies/algorithms.py`, for example:

     ```python
     def my_algo_rebalance(
         current_units: np.ndarray,
         prices: np.ndarray,
         fees: float,
     ) -> tuple[np.ndarray, float]:
         """Custom rebalance logic."""
         # Your logic here
         return new_units, new_portfolio_value
     ```

  2. Register the algorithm in `backend/service.py`:

     ```python
     from strategies.algorithms import my_algo_rebalance

     ALGORITHM_MAP["my_algo"] = {
         "fn": my_algo_rebalance,
         "label": "My Custom Algorithm",
         "description": "Custom rebalance strategy description",
     }
     ```

  3. The new algorithm will automatically appear in `/api/algorithms` and the `/ui` dropdown. Use the `key` (`"my_algo"`) in the `algorithm` field of `/api/backtest` requests.

---

## Notes

- The original README mentioned a "LongPort API", which is not currently used in this codebase. The current implementation relies on Yahoo Finance (`yfinance`) as the primary data source.
- If you plan to connect to a live trading API in the future, you can layer execution logic on top of this backtesting framework, reusing the data pipeline and strategy logic.
